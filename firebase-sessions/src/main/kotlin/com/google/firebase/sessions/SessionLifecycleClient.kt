package com.google.firebase.sessions

import android.app.Activity
import android.content.ComponentName
import android.content.Context
import android.content.Intent
import android.content.ServiceConnection
import android.os.Handler
import android.os.IBinder
import android.os.Looper
import android.os.Message
import android.os.Messenger
import android.os.RemoteException
import android.util.Log
import java.util.LinkedList

/**
 * Client for binding to the [SessionLifecycleService]. This client will receive updated sessions
 * through a callback whenever a new session is generated by the service, or after the initial
 * binding.
 *
 * Note: this client will be connected in every application process that uses Firebase, and is
 * intended to maintain that connection for the lifetime of the process.
 */
object SessionLifecycleClient {
  const val TAG = "SessionLifecycleClient"

  /**
   * The maximum number of messages that we should queue up for delivery to the
   * [SessionLifecycleService] in the event that we have lost the connection.
   */
  const val MAX_QUEUED_MESSAGES = 20

  private var service: Messenger? = null
  private var serviceBound: Boolean = false
  private val queuedMessages = LinkedList<Message>()
  private var curSessionId: String = ""

  /**
   * The callback class that will be used to receive updated session events from the
   * [SessionLifecycleService].
   */
  internal class ClientUpdateHandler() : Handler(Looper.getMainLooper()) {
    override fun handleMessage(msg: Message) {
      when (msg.what) {
        SessionLifecycleService.SESSION_UPDATED ->
          handleSessionUpdate(
            msg.data?.getString(SessionLifecycleService.SESSION_UPDATE_EXTRA) ?: ""
          )
        else -> {
          Log.w(TAG, "Received unexpected event from the SessionLifecycleService: $msg")
          super.handleMessage(msg)
        }
      }
    }

    fun handleSessionUpdate(sessionId: String) {
      Log.i(TAG, "Session update received: $sessionId")
      curSessionId = sessionId
    }
  }

  /** The connection object to the [SessionLifecycleService]. */
  private val serviceConnection =
    object : ServiceConnection {
      override fun onServiceConnected(className: ComponentName, serviceBinder: IBinder) {
        Log.i(TAG, "Connected to SessionLifecycleService. Queue size ${queuedMessages.size}")
        service = Messenger(serviceBinder)
        serviceBound = true
        val queueItr = queuedMessages.iterator()
        for (msg in queueItr) {
          Log.i(TAG, "sending queued message ${msg.what}")
          sendLifecycleEvent(msg)
          queueItr.remove()
        }
      }

      override fun onServiceDisconnected(className: ComponentName) {
        Log.i(TAG, "Disconnected from SessionLifecycleService")
        service = null
        serviceBound = false
      }
    }

  /**
   * Binds to the [SessionLifecycleService] and passes a callback [Messenger] that will be used to
   * relay session updates to this client.
   */
  fun bindToService(appContext: Context): Unit {
    Intent(appContext, SessionLifecycleService::class.java).also { intent ->
      Log.i(TAG, "Binding service to application.")
      // This is necessary for the onBind() to be called by each process
      intent.setAction(android.os.Process.myPid().toString())
      intent.putExtra(
        SessionLifecycleService.CLIENT_CALLBACK_MESSENGER,
        Messenger(ClientUpdateHandler())
      )
      appContext.bindService(
        intent,
        serviceConnection,
        Context.BIND_IMPORTANT or Context.BIND_AUTO_CREATE
      )
    }
  }

  /**
   * Should be called when any activity in this application process goes to the foreground. This
   * will relay the event to the [SessionLifecycleService] where it can make the determination of
   * whether or not this foregrounding event should result in a new session being generated.
   */
  fun foregrounded(activity: Activity): Unit {
    sendLifecycleEvent(SessionLifecycleService.FOREGROUNDED)
  }

  /**
   * Should be called when any activity in this application process goes from the foreground to the
   * background. This will relay the event to the [SessionLifecycleService] where it will be used to
   * determine when a new session should be generated.
   */
  fun backgrounded(activity: Activity): Unit {
    sendLifecycleEvent(SessionLifecycleService.BACKGROUNDED)
  }

  /** Sends a message to the [SessionLifecycleService] with the given event code. */
  private fun sendLifecycleEvent(messageCode: Int) {
    sendLifecycleEvent(Message.obtain(null, messageCode, 0, 0))
  }

  /** Sends the given [Message] to the [SessionLifecycleService]. */
  private fun sendLifecycleEvent(msg: Message) {
    if (service != null) {
      try {
        service?.send(msg)
      } catch (e: RemoteException) {
        Log.e(TAG, "Unable to deliver message: ${msg.what}")
        queueMessage(msg)
      }
    } else {
      queueMessage(msg)
    }
  }

  /**
   * Queues the given [Message] up for delivery to the [SessionLifecycleService] once the connection
   * is established.
   */
  private fun queueMessage(msg: Message) {
    Log.i(TAG, "Queueing message ${msg.what}")
    queuedMessages.add(msg)
    while (queuedMessages.size > MAX_QUEUED_MESSAGES) {
      queuedMessages.removeFirst()
    }
  }
}
