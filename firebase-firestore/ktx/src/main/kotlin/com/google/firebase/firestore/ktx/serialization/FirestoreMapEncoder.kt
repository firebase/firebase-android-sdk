// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package com.google.firebase.firestore.ktx.serialization

import com.google.firebase.firestore.FieldValue
import com.google.firebase.firestore.ktx.annotations.KDocumentId
import com.google.firebase.firestore.ktx.annotations.KServerTimestamp
import com.google.firebase.firestore.ktx.serializers.FirestoreSerializersModule
import kotlinx.serialization.SerializationStrategy
import kotlinx.serialization.descriptors.PrimitiveKind
import kotlinx.serialization.descriptors.SerialDescriptor
import kotlinx.serialization.descriptors.SerialKind
import kotlinx.serialization.descriptors.StructureKind
import kotlinx.serialization.descriptors.elementDescriptors
import kotlinx.serialization.encoding.AbstractEncoder
import kotlinx.serialization.encoding.CompositeEncoder
import kotlinx.serialization.modules.SerializersModule
import kotlinx.serialization.serializer

/**
 * The entry point of Firestore Kotlin Serialization Process. It encodes a custom @Serializable
 * Kotlin object into a nested map of primitives. SDK users don’t need to directly interact with
 * [FirestoreMapEncoder].
 *
 * <p>For a custom @Serializable object, at compile time, a serializer will be generated by the
 * Kotlin serialization compiler plugin (or a custom serializer can be manually passed in). The
 * structure information of the custom @Serializable object will be recorded inside of the
 * serializer’s descriptor (i.e. the name/type of each property to be encoded, the annotation on
 * each property).
 *
 * <p>Based on the descriptor’s information, during the encoding process, a nested map will be
 * generated. Each property which has its own structure (i.e. a nested custom object, a nested list)
 * will be encoded as an embedded map nested inside. At the end, the nested map at depth == 1 will
 * be returned as the nested map representing the entire custom @Serializable object.
 *
 * @param map the nested map that records the encoded result of the original @Serializable object.
 * @param depth the current encoding depth inside of the nested map.
 * @param descriptor a [SerialDescriptor] of the custom object.
 */
class FirestoreMapEncoder(
    private val map: MutableMap<Int, MutableMap<String, Any?>> = mutableMapOf(),
    private var depth: Int = 0,
    private val descriptor: SerialDescriptor? = null
) : AbstractEncoder() {

    companion object {
        private const val ROOT_LEVEL: Int = 1
        private const val MAX_DEPTH: Int = 500
    }

    private sealed class Element {
        // Invalid Element can be generated under situation like depth level 0, descriptor is null,
        // etc, these no valid element will not be involved in the actual value-encoding process.
        object NoValidElement : Element()
    }

    /**
     * The data class records the information for the valid field element that needs to be encoded.
     */
    private inner class ValidElement(elementIndex: Int, elementEncodeKey: String) : Element() {
        val elementIndex: Int = elementIndex
        val elementEncodeKey: String = elementEncodeKey
        val elementKind: SerialKind? = descriptor?.getElementKindOrNull(this.elementIndex)
        val elementSerialName: String? = descriptor?.getElementSerialNameOrNull(this.elementIndex)
        val elementAnnotations: List<Annotation>? =
            descriptor?.elementAnnotationsOrNull(this.elementIndex)
    }

    /**
     * Returns the [Element] that being encoded at a given index, elementIndex.
     * [Element.NoValidElement] will be returned in case the element can not be obtained.
     * [ValidElement] will be returned in case the element can be obtained.
     */
    private fun getEncodeElementFromIndex(elementIndex: Int = 0): Element {
        val encodeKey =
            descriptor?.getElementNameOrNull(elementIndex) ?: return Element.NoValidElement
        return ValidElement(elementIndex, encodeKey)
    }

    private var isFirstEncodingElement: Boolean = true

    private var currentElement: Element = getEncodeElementFromIndex()

    // Factory method to update the [currentElement] property with the next element that need to
    // be encoded.
    private fun generateCurrentElementForEncoding() {
        if (isFirstEncodingElement) {
            isFirstEncodingElement = false
        } else {
            updateCurrentElementOrThrow(currentElement)
        }
    }

    private fun updateCurrentElementOrThrow(currentElement: Element) {
        when (currentElement) {
            is Element.NoValidElement ->
                throw IllegalArgumentException(
                    "The current element that is being encoded is invalid."
                )
            is ValidElement ->
                this.currentElement = getEncodeElementFromIndex(currentElement.elementIndex + 1)
        }
    }

    init {
        if (depth == ROOT_LEVEL) map[ROOT_LEVEL] = mutableMapOf()
        if (depth == MAX_DEPTH) {
            throw IllegalArgumentException(
                "Exceeded maximum depth of $MAX_DEPTH, which likely indicates there's an object cycle"
            )
        }
    }

    /** Returns the final encoded nested map. */
    fun serializedResult() = map.getValue(ROOT_LEVEL)

    /** Get the field name of an enum via index, and encode it to the nested map. */
    override fun encodeEnum(enumDescriptor: SerialDescriptor, index: Int) =
        encodeValue(enumDescriptor.getElementName(index))

    /**
     * Register serializers for Firestore native data types, [DocumentId], [Timestamp], [Date], and
     * [GeoPoint], so that these registered serializers can be used at run-time to serialize the
     * fields with @[Contextual] annotations
     */
    override val serializersModule: SerializersModule = FirestoreSerializersModule

    /**
     * Encode the native Firestore datatype objects: [DocumentId], [Timestamp], [Date], and
     * [GeoPoint].
     */
    fun <T> encodeFirestoreNativeDataType(value: T) {
        generateCurrentElementForEncoding()
        validateKServerTimestampPresentOrThrow(currentElement)
        when {
            // KDocumentId on DocumentReference, then ignore
            validateKDocumentIdPresentOrThrow(currentElement) -> {}
            else -> encodeValidElementOrThrow(currentElement, value)
        }
    }

    override fun encodeNull() {
        generateCurrentElementForEncoding()
        when {
            // KDocumentId on String?, DocumentReference?, then ignore,
            validateKDocumentIdPresentOrThrow(currentElement) -> {}
            validateKServerTimestampPresentOrThrow(currentElement) ->
                encodeValidElementOrThrow(
                    currentElement,
                    FieldValue.serverTimestamp()
                ) // KServerTimestamp on Timestamp? = null, then replace with FieldValue
            else -> encodeValidElementOrThrow(currentElement, null)
        }
    }

    override fun encodeValue(value: Any) {
        generateCurrentElementForEncoding()
        when {
            // KDocumentId on String, then ignore
            validateKDocumentIdPresentOrThrow(currentElement) -> {}
            // KServerTimestamp can not on Primitives
            validateKServerTimestampPresentOrThrow(currentElement) -> {}
            else -> encodeValidElementOrThrow(currentElement, value)
        }
    }

    override fun endStructure(descriptor: SerialDescriptor) {
        if (depth != ROOT_LEVEL) {
            map.remove(depth--)
        }
    }

    /**
     * Recursively build the nested map when an encoded property has its own structure (i.e. a
     * nested custom @Serializable object, a nested list)
     *
     * @param descriptor the [SerialDescriptor] of the @Serializable object at current depth.
     * @return a CompositeEncoder either to be a [FirestoreMapEncoder] or a [FirestoreListEncoder].
     */
    override fun beginStructure(descriptor: SerialDescriptor): CompositeEncoder {
        throwOnInvalidKDocumentIdAndKServerTimestampAnnotation()
        if (depth == 0) {
            return FirestoreMapEncoder(map, depth + 1, descriptor)
        }
        when (descriptor.kind) {
            StructureKind.CLASS -> {
                val nextDepth = depth + 1
                map[nextDepth] = mutableMapOf()
                generateCurrentElementForEncoding()
                encodeValidElementOrThrow(currentElement, map[nextDepth])
                return FirestoreMapEncoder(map, nextDepth, descriptor)
            }
            StructureKind.LIST -> {
                val emptyList = mutableListOf<Any?>()
                generateCurrentElementForEncoding()
                encodeValidElementOrThrow(currentElement, emptyList)
                return FirestoreListEncoder(map, depth, emptyList)
            }
            else -> {
                throw IllegalArgumentException(
                    "Incorrect format of nested object provided: <$descriptor.kind>"
                )
            }
        }
    }

    private fun encodeValidElementOrThrow(currentElement: Element, value: Any?) {
        when (currentElement) {
            is ValidElement -> map.getValue(depth).put(currentElement.elementEncodeKey, value)
            is Element.NoValidElement ->
                throw IllegalArgumentException(
                    "The current element that is being encoded is invalid."
                )
        }
    }

    /**
     * Returns true is @[KDocumentId] is applied to a property of a type [String] or
     * [DocumentReference]; Otherwise, a runtime exception will be thrown.
     */
    private fun kDocumentIdAppliedOnValidProperty(currentElement: ValidElement): Boolean {
        val isDocumentReference =
            currentElement.elementSerialName?.contains("<DocumentReference>") ?: false
        if (currentElement.elementKind == PrimitiveKind.STRING || isDocumentReference) {
            return true
        } else {
            throw IllegalArgumentException(
                "Field is annotated with @KDocumentId but is class $currentElement.elementKind ( with serial name ${currentElement.elementSerialName} ) instead of String or DocumentReference."
            )
        }
    }

    /**
     * Returns true if @[KDocumentId] is present and applied on a property of String or
     * DocumentReference; Returns false if @[KDocumentId] is absent; Throws runtime exception if @
     * [KDocumentId] is present but applied on a property of an invalid type.
     */
    private fun validateKDocumentIdPresentOrThrow(currentElement: Element): Boolean {
        return when (currentElement) {
            is Element.NoValidElement -> false
            is ValidElement -> correctKDocumentIdPresentOnValidElementOrThrow(currentElement)
        }
    }

    private fun correctKDocumentIdPresentOnValidElementOrThrow(
        currentElement: ValidElement
    ): Boolean {
        val kDocumentIdPresent = currentElement.elementAnnotations?.any { it is KDocumentId }
        return if (kDocumentIdPresent == true) {
            kDocumentIdAppliedOnValidProperty(currentElement)
        } else {
            false
        }
    }

    /**
     * Returns true is @[KServerTimestamp] is applied to a property of a type Date or Timestamp;
     * Otherwise, a runtime exception will be thrown.
     */
    private fun kServerTimestampAppliedOnValidProperty(currentElement: ValidElement): Boolean {
        val isTimestamp = currentElement.elementSerialName?.contains("<Timestamp>") ?: false
        val isDate = currentElement.elementSerialName?.contains("<Date>") ?: false
        if (isTimestamp || isDate) {
            return true
        } else {
            throw IllegalArgumentException(
                "Field is annotated with @KServerTimestamp but is class $currentElement.elementKind ( with serial name ${currentElement.elementSerialName} ) instead of Date or Timestamp."
            )
        }
    }

    /**
     * Returns true if @[KServerTimestamp] is present and applied on a property of Date or
     * Timestamp; Returns false if @[KServerTimestamp] is absent; Throws runtime exception if @
     * [KServerTimestamp] is present but applied on a property of an invalid type.
     */
    private fun validateKServerTimestampPresentOrThrow(currentElement: Element): Boolean {
        return when (currentElement) {
            is Element.NoValidElement -> false
            is ValidElement -> correctKServerTimestampPresentOnValidElementOrThrow(currentElement)
        }
    }

    private fun correctKServerTimestampPresentOnValidElementOrThrow(
        currentElement: ValidElement
    ): Boolean {
        val kServerTimestampPresent =
            currentElement.elementAnnotations?.any { it is KServerTimestamp }
        return if (kServerTimestampPresent == true) {
            kServerTimestampAppliedOnValidProperty(currentElement)
        } else {
            false
        }
    }

    /**
     * Throw runtime exception if [KDocumentId] or [KServerTimestamp] is applied on a property of an
     * invalid type
     */
    private fun throwOnInvalidKDocumentIdAndKServerTimestampAnnotation() {
        validateKDocumentIdPresentOrThrow(currentElement)
        validateKServerTimestampPresentOrThrow(currentElement)
    }
}

/**
 * The entry point of encoding a List type property during Firestore Kotlin Serialization Process.
 * It encodes a List type property inside of a custom @Serializable Kotlin object, converts it into
 * a list of primitives or a list of nested maps. SDK users don’t need to directly interact with
 * [FirestoreListEncoder].
 *
 * @param map the nested map that records the encoded result of the original @Serializable object.
 * @param depth the current encoding depth inside of the nested map.
 * @param encodedList the encoded result of the current nested list.
 */
class FirestoreListEncoder(
    private val map: MutableMap<Int, MutableMap<String, Any?>> = mutableMapOf(),
    private val depth: Int = 0,
    private val encodedList: MutableList<Any?> = mutableListOf()
) : AbstractEncoder() {

    /**
     * Register serializers for Firestore native data types, DocumentId, Timestamp, and GeoPoint, so
     * that these registered serializers can be used at run-time to serialize the fields with
     * @Contextual annotations
     */
    override val serializersModule: SerializersModule = FirestoreSerializersModule

    /** Encode the native Firestore datatype objects: DocumentId, Timestamp, and GeoPoint. */
    fun <T> encodeFirestoreNativeDataType(value: T) {
        encodedList.add(value)
        elementIndex++
    }

    private var elementIndex: Int = 0

    override fun encodeValue(value: Any) {
        encodedList.add(value)
        elementIndex++
    }

    override fun encodeNull() {
        encodedList.add(null)
        elementIndex++
    }

    /**
     * Recursively build the nested map when the element inside of the nested list has its own
     * structure (i.e. a list of nested custom @Serializable object)
     *
     * <p>Note: Firestore does not support read/write high dimensional nested lists; therefore,
     * list's content must be either primitive type elements or @Serializable objects.
     * IllegalArgumentException will be thrown if list contains elements of other types.
     *
     * @param descriptor the [SerialDescriptor] of the @Serializable object at current depth.
     * @return a [FirestoreMapEncoder].
     */
    override fun beginStructure(descriptor: SerialDescriptor): CompositeEncoder {
        when (descriptor.kind) {
            StructureKind.CLASS -> {
                val nextDepth = depth + 1
                map[nextDepth] = mutableMapOf()
                encodedList.add(map[nextDepth])
                return FirestoreMapEncoder(map, nextDepth, descriptor)
            }
            else -> {
                throw IllegalArgumentException(
                    "Incorrect format of nested object provided: <$descriptor.kind>"
                )
            }
        }
    }
}

/**
 * Return a list of annotations of the child element at a given index [elementIndex]; In case of
 * [IndexOutOfBoundsException], and [IllegalArgumentException], null will be returned. Other types
 * of exception will be raised.
 */
private fun SerialDescriptor.elementAnnotationsOrNull(elementIndex: Int): List<Annotation>? =
    try {
        getElementAnnotations(elementIndex)
    } catch (err: Exception) {
        when (err) {
            is IndexOutOfBoundsException,
            is IllegalArgumentException -> null
            else -> throw err
        }
    }

private fun SerialDescriptor.getElementNameOrNull(elementIndex: Int): String? =
    try {
        getElementName(elementIndex)
    } catch (err: Exception) {
        when (err) {
            is IndexOutOfBoundsException,
            is IllegalArgumentException -> null
            else -> throw err
        }
    }

private fun SerialDescriptor.getElementKindOrNull(elementIndex: Int): SerialKind? =
    elementDescriptors?.toList()?.getOrNull(elementIndex)?.kind

private fun SerialDescriptor.getElementSerialNameOrNull(elementIndex: Int): String? =
    elementDescriptors?.toList()?.getOrNull(elementIndex)?.serialName

/**
 * Returns the encoded contents of a @Serializable object converted to a nested map.
 *
 * @param serializer The SerializationStrategy of the @Serializable Kotlin object.
 * @param value The @Serializable Kotlin object.
 * @return The encoded nested map of a @Serializable Kotlin object.
 */
fun <T> encodeToMap(serializer: SerializationStrategy<T>, value: T): MutableMap<String, Any?> {
    val encoder = FirestoreMapEncoder()
    encoder.encodeSerializableValue(serializer, value)
    return encoder.serializedResult()
}

/**
 * Returns the encoded contents of a @Serializable object converted to a nested map.
 *
 * @param value The @Serializable Kotlin object.
 * @return The encoded nested map of a @Serializable Kotlin object.
 */
inline fun <reified T> encodeToMap(value: T): MutableMap<String, Any?> =
    encodeToMap(serializer(), value)
