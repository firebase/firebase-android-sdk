// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.


repositories {
    maven {
        url '../../build/m2repository/'
    }
    google()
    jcenter()
}

// firebase-inappmessaging-display fails with `java.lang.OutOfMemoryError (no error message)`
// in task `:transformDexArchiveWithExternalLibsDexMergerForFirebase-inappmessaging-displayRelease`
//
// firebase-inappmessaging-display-ktx fails with `java.lang.OutOfMemoryError: GC overhead limit exceeded`
// in task `:transformClassesAndResourcesWithR8ForFirebase-inappmessaging-display-ktxAggressive`
//
// Setting max heap size to 16g in gradle.properties and android.dexOptions did not help.
// When running with `gradle --continue`, failing tasks did not timeout. Thus, disable for now.
// TODO (yifany): Needs further investigation.
def blacklist = [
        'firebase-inappmessaging-display',
        'firebase-inappmessaging-display-ktx'
]
if (project.hasProperty('sdks')) {
    project.android {
        sdks.split(',').each { sdk ->
            def (groupId, artifactId, version) = sdk.split(':')
            if (blacklist.contains(artifactId)) {
                return
            }
            productFlavors.create(artifactId) {
                dimension 'apkSize'
            }
            dependencies.add("${artifactId}Implementation", sdk)
        }
    }
}


// Configures two new tasks `unpack` and `repack` for each `assemble` task created for all
// configured application build variants.
//
// `unpack` task takes the apk file and unpacks it into a folder `archive`. `repack` task compresses
// the folder back into a zip file. The size of the generated zip file will then be collected as the
// stable version of the size for its corresponding apk file.
project.afterEvaluate {
    def unpack = project.tasks.create("unpack")
    def repack = project.tasks.create("repack")

    android.applicationVariants.all {
        def assemble = it.assembleProvider.get()
        def packageApplication = it.packageApplicationProvider.get()
        def apk = packageApplication.apkNames[0]
        def dir = packageApplication.outputDirectory
        def unpackTaskName = "unpack" + it.name.capitalize()
        def repackTaskName = "repack" + it.name.capitalize()

        def unpackVariant = project.tasks.create(unpackTaskName, Copy.class) {
            dependsOn assemble

            from zipTree(file("$dir/$apk"))
            into file("$dir/archive")
        }
        unpack.dependsOn unpackVariant

        def repackVariant = project.tasks.create(repackTaskName, Zip.class) {
            dependsOn unpackTaskName

            archiveFileName = apk.replace(".apk", ".zip")
            destinationDirectory = file(dir)
            from "$dir/archive"
        }
        repack.dependsOn repackVariant
    }
}
