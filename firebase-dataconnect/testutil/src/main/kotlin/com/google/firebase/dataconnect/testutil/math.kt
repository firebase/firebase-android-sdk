/*
 * Copyright 2025 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.firebase.dataconnect.testutil

import io.kotest.matchers.doubles.shouldBeLessThan
import kotlin.math.absoluteValue
import kotlin.math.pow
import kotlin.math.sqrt

/**
 * Calculates the standard deviation of a list of numbers.
 *
 * In statistics, the standard deviation (Ïƒ or s) is a measure of how spread out the numbers in a
 * set of data are from their mean (average). It tells you, on average, how far each data point
 * deviates from the central value.
 *
 * This implementation computes the _sample_ standard deviation, as opposed to the _population_
 * standard deviation. As a result, the size of the list on which this method is invoked must be at
 * least 2.
 */
@JvmName("calculateStandardDeviationDoubleList")
fun List<Double>.calculateStandardDeviation(): Double {
  // Note: This function was generated by Gemini, and slightly adapted.

  require(size > 1) { "the list has size $size, which has an undefined sample standard deviation" }

  // Step 1: Calculate the mean
  val mean = average()

  // Step 2: Calculate the sum of squared differences from the mean
  val sumOfSquaredDifferences = sumOf { (it - mean).pow(2) }

  // Step 3: Calculate the variance
  // For sample standard deviation, use (n - 1) in the denominator.
  // For population standard deviation, use n.
  // We'll use (n - 1) for sample standard deviation, which is more common in practice.
  val variance = sumOfSquaredDifferences / (size - 1)

  // Step 4: Calculate the standard deviation (square root of variance)
  return sqrt(variance)
}

@JvmName("calculateStandardDeviationDoubleIterable")
fun Iterable<Double>.calculateStandardDeviation(): Double = toList().calculateStandardDeviation()

@JvmName("calculateStandardDeviationIntList")
fun List<Int>.calculateStandardDeviation(): Double =
  map { it.toDouble() }.calculateStandardDeviation()

@JvmName("calculateStandardDeviationIntIterable")
fun Iterable<Int>.calculateStandardDeviation(): Double = toList().calculateStandardDeviation()

@JvmName("shouldHaveStandardDeviationLessThanInt")
infix fun Iterable<Int>.shouldHaveStandardDeviationLessThan(max: Number) {
  calculateStandardDeviation() shouldBeLessThan max.toDouble()
}

@JvmName("shouldHaveStandardDeviationLessThanDouble")
infix fun Iterable<Double>.shouldHaveStandardDeviationLessThan(max: Number) {
  calculateStandardDeviation() shouldBeLessThan max.toDouble()
}

/**
 * Returns the number of digits in a base-10 string representation of the receiver [Int] value.
 *
 * The count does _not_ include the minus sign. Therefore, both `-123` and `123` are considered to
 * have 3 digits by this function. To state the obvious, the value of `0` is reported to have 1
 * digit by this function.
 *
 * If the value of the receiver [Int] is negative then the negation of the digit count is returned.
 * Therefore, this function returns values between -10 and 10, excluding 0.
 */
fun Int.calculateNumBase10Digits(): Int {
  val absoluteNumDigits = if (this == Int.MIN_VALUE) -10 else absoluteValue.toString().length
  return if (this < 0) -absoluteNumDigits else absoluteNumDigits
}
