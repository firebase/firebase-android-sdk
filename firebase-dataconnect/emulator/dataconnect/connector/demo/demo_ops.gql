# Copyright 2024 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

mutation InsertFoo($id: String!, $bar: String)
    @auth(level: PUBLIC) {
  foo_insert(data: {id: $id, bar: $bar})
}

mutation UpsertFoo($id: String!, $bar: String)
    @auth(level: PUBLIC) {
  foo_upsert(data: {id: $id, bar: $bar})
}

mutation DeleteFoo($id: String!)
    @auth(level: PUBLIC) {
  foo_delete(id: $id)
}

mutation DeleteFoosByBar($bar: String!)
    @auth(level: PUBLIC) {
  foo_deleteMany(where: {bar: {eq: $bar}})
}

mutation UpdateFoo($id: String!, $newBar: String)
    @auth(level: PUBLIC) {
  foo_update(id: $id, data: {bar: $newBar})
}

mutation UpdateFoosByBar($oldBar: String, $newBar: String)
    @auth(level: PUBLIC) {
  foo_updateMany(where: {bar: {eq: $oldBar}}, data: {bar: $newBar})
}

query GetFooById($id: String!)
    @auth(level: PUBLIC) {
  foo(id: $id) {
    bar
  }
}

query GetFoosByBar($bar: String)
    @auth(level: PUBLIC) {
  foos(where: {bar: {eq: $bar}}) {
    id
  }
}

# This is an example mutation that has no variables, for testing purposes.
mutation UpsertHardcodedFoo
    @auth(level: PUBLIC) {
  foo_upsert(data: {id: "18e61f0a-8abc-4b18-9c4c-28c2f4e82c8f", bar: "BAR"})
}

# This is an example query that has no variables, for testing purposes.
query GetHardcodedFoo
    @auth(level: PUBLIC) {
  foo(id: "18e61f0a-8abc-4b18-9c4c-28c2f4e82c8f") {
    bar
  }
}

mutation InsertStringVariants(
  $id: String!,
  $nonNullWithNonEmptyValue: String!,
  $nonNullWithEmptyValue: String!,
  $nullableWithNullValue: String,
  $nullableWithNonNullValue: String,
  $nullableWithEmptyValue: String,
) @auth(level: PUBLIC) {
  stringVariants_insert(data: {
    id: $id,
    nonNullWithNonEmptyValue: $nonNullWithNonEmptyValue,
    nonNullWithEmptyValue: $nonNullWithEmptyValue,
    nullableWithNullValue: $nullableWithNullValue,
    nullableWithNonNullValue: $nullableWithNonNullValue,
    nullableWithEmptyValue: $nullableWithEmptyValue,
  })
}

query GetStringVariantsById($id: String!) @auth(level: PUBLIC) {
  stringVariants(id: $id) {
    nonNullWithNonEmptyValue
    nonNullWithEmptyValue
    nullableWithNullValue
    nullableWithNonNullValue
    nullableWithEmptyValue
  }
}

mutation InsertIntVariants(
  $id: String!,
  $nonNullWithZeroValue: Int!,
  $nonNullWithPositiveValue: Int!,
  $nonNullWithNegativeValue: Int!,
  $nonNullWithMaxValue: Int!,
  $nonNullWithMinValue: Int!,
  $nullableWithNullValue: Int,
  $nullableWithZeroValue: Int,
  $nullableWithPositiveValue: Int,
  $nullableWithNegativeValue: Int,
  $nullableWithMaxValue: Int,
  $nullableWithMinValue: Int,
) @auth(level: PUBLIC) {
  intVariants_insert(data: {
    id: $id,
    nonNullWithZeroValue: $nonNullWithZeroValue,
    nonNullWithPositiveValue: $nonNullWithPositiveValue,
    nonNullWithNegativeValue: $nonNullWithNegativeValue,
    nonNullWithMaxValue: $nonNullWithMaxValue,
    nonNullWithMinValue: $nonNullWithMinValue,
    nullableWithNullValue: $nullableWithNullValue,
    nullableWithZeroValue: $nullableWithZeroValue,
    nullableWithPositiveValue: $nullableWithPositiveValue,
    nullableWithNegativeValue: $nullableWithNegativeValue,
    nullableWithMaxValue: $nullableWithMaxValue,
    nullableWithMinValue: $nullableWithMinValue,
  })
}

query GetIntVariantsById($id: String!) @auth(level: PUBLIC) {
  intVariants(id: $id) {
    nonNullWithZeroValue
    nonNullWithPositiveValue
    nonNullWithNegativeValue
    nonNullWithMaxValue
    nonNullWithMinValue
    nullableWithNullValue
    nullableWithZeroValue
    nullableWithPositiveValue
    nullableWithNegativeValue
    nullableWithMaxValue
    nullableWithMinValue
  }
}

mutation InsertFloatVariants(
  $id: String!,
  $nonNullWithZeroValue: Float!,
  $nonNullWithNegativeZeroValue: Float!,
  $nonNullWithPositiveValue: Float!,
  $nonNullWithNegativeValue: Float!,
  $nonNullWithMaxValue: Float!,
  $nonNullWithMinValue: Float!,
  $nonNullWithMaxSafeIntegerValue: Float!,
  $nullableWithNullValue: Float,
  $nullableWithZeroValue: Float,
  $nullableWithNegativeZeroValue: Float,
  $nullableWithPositiveValue: Float,
  $nullableWithNegativeValue: Float,
  $nullableWithMaxValue: Float,
  $nullableWithMinValue: Float,
  $nullableWithMaxSafeIntegerValue: Float,
) @auth(level: PUBLIC) {
  floatVariants_insert(data: {
    id: $id,
    nonNullWithZeroValue: $nonNullWithZeroValue,
    nonNullWithNegativeZeroValue: $nonNullWithNegativeZeroValue,
    nonNullWithPositiveValue: $nonNullWithPositiveValue,
    nonNullWithNegativeValue: $nonNullWithNegativeValue,
    nonNullWithMaxValue: $nonNullWithMaxValue,
    nonNullWithMinValue: $nonNullWithMinValue,
    nonNullWithMaxSafeIntegerValue: $nonNullWithMaxSafeIntegerValue,
    nullableWithNullValue: $nullableWithNullValue,
    nullableWithZeroValue: $nullableWithZeroValue,
    nullableWithNegativeZeroValue: $nullableWithNegativeZeroValue,
    nullableWithPositiveValue: $nullableWithPositiveValue,
    nullableWithNegativeValue: $nullableWithNegativeValue,
    nullableWithMaxValue: $nullableWithMaxValue,
    nullableWithMinValue: $nullableWithMinValue,
    nullableWithMaxSafeIntegerValue: $nullableWithMaxSafeIntegerValue,
  })
}

query GetFloatVariantsById($id: String!) @auth(level: PUBLIC) {
  floatVariants(id: $id) {
    nonNullWithZeroValue
    nonNullWithNegativeZeroValue
    nonNullWithPositiveValue
    nonNullWithNegativeValue
    nonNullWithMaxValue
    nonNullWithMinValue
    nonNullWithMaxSafeIntegerValue
    nullableWithNullValue
    nullableWithZeroValue
    nullableWithNegativeZeroValue
    nullableWithPositiveValue
    nullableWithNegativeValue
    nullableWithMaxValue
    nullableWithMinValue
    nullableWithMaxSafeIntegerValue
  }
}

mutation InsertBooleanVariants(
  $id: String!,
  $nonNullWithTrueValue: Boolean!,
  $nonNullWithFalseValue: Boolean!,
  $nullableWithNullValue: Boolean,
  $nullableWithTrueValue: Boolean,
  $nullableWithFalseValue: Boolean,
) @auth(level: PUBLIC) {
  booleanVariants_insert(data: {
    id: $id,
    nonNullWithTrueValue: $nonNullWithTrueValue,
    nonNullWithFalseValue: $nonNullWithFalseValue,
    nullableWithNullValue: $nullableWithNullValue,
    nullableWithTrueValue: $nullableWithTrueValue,
    nullableWithFalseValue: $nullableWithFalseValue,
  })
}

query GetBooleanVariantsById($id: String!) @auth(level: PUBLIC) {
  booleanVariants(id: $id) {
    nonNullWithTrueValue
    nonNullWithFalseValue
    nullableWithNullValue
    nullableWithTrueValue
    nullableWithFalseValue
  }
}

mutation InsertInt64Variants(
  $id: String!,
  $nonNullWithZeroValue: Int64!,
  $nonNullWithPositiveValue: Int64!,
  $nonNullWithNegativeValue: Int64!,
  $nonNullWithMaxValue: Int64!,
  $nonNullWithMinValue: Int64!,
  $nullableWithNullValue: Int64,
  $nullableWithZeroValue: Int64,
  $nullableWithPositiveValue: Int64,
  $nullableWithNegativeValue: Int64,
  $nullableWithMaxValue: Int64,
  $nullableWithMinValue: Int64,
) @auth(level: PUBLIC) {
  int64Variants_insert(data: {
    id: $id,
    nonNullWithZeroValue: $nonNullWithZeroValue,
    nonNullWithPositiveValue: $nonNullWithPositiveValue,
    nonNullWithNegativeValue: $nonNullWithNegativeValue,
    nonNullWithMaxValue: $nonNullWithMaxValue,
    nonNullWithMinValue: $nonNullWithMinValue,
    nullableWithNullValue: $nullableWithNullValue,
    nullableWithZeroValue: $nullableWithZeroValue,
    nullableWithPositiveValue: $nullableWithPositiveValue,
    nullableWithNegativeValue: $nullableWithNegativeValue,
    nullableWithMaxValue: $nullableWithMaxValue,
    nullableWithMinValue: $nullableWithMinValue,
  })
}

query GetInt64VariantsById($id: String!) @auth(level: PUBLIC) {
  int64Variants(id: $id) {
    nonNullWithZeroValue
    nonNullWithPositiveValue
    nonNullWithNegativeValue
    nonNullWithMaxValue
    nonNullWithMinValue
    nullableWithNullValue
    nullableWithZeroValue
    nullableWithPositiveValue
    nullableWithNegativeValue
    nullableWithMaxValue
    nullableWithMinValue
  }
}

mutation InsertUUIDVariants(
  $id: String!,
  $nonNullValue: UUID!,
  $nullableWithNullValue: UUID,
  $nullableWithNonNullValue: UUID,
) @auth(level: PUBLIC) {
  uUIDVariants_insert(data: {
    id: $id,
    nonNullValue: $nonNullValue,
    nullableWithNullValue: $nullableWithNullValue,
    nullableWithNonNullValue: $nullableWithNonNullValue,
  })
}

query GetUUIDVariantsById($id: String!) @auth(level: PUBLIC) {
  uUIDVariants(id: $id) {
    nonNullValue
    nullableWithNullValue
    nullableWithNonNullValue
  }
}

mutation InsertTimestampVariants(
  $id: String!,
  $nonNullValue: Timestamp!,
  $nullableWithNullValue: Timestamp,
  $nullableWithNonNullValue: Timestamp,
  $minValue: Timestamp!,
  $maxValue: Timestamp!,
) @auth(level: PUBLIC) {
  timestampVariants_insert(data: {
    id: $id,
    nonNullValue: $nonNullValue,
    nullableWithNullValue: $nullableWithNullValue,
    nullableWithNonNullValue: $nullableWithNonNullValue,
    minValue: $minValue,
    maxValue: $maxValue,
  })
}

query GetTimestampVariantsById($id: String!) @auth(level: PUBLIC) {
  timestampVariants(id: $id) {
    nonNullValue
    nullableWithNullValue
    nullableWithNonNullValue
    minValue
    maxValue
  }
}

mutation InsertDateVariants(
  $id: String!,
  $nonNullValue: Date!,
  $nullableWithNullValue: Date,
  $nullableWithNonNullValue: Date,
  $minValue: Date!,
  $maxValue: Date!,
  $nonZeroTime: Date!,
) @auth(level: PUBLIC) {
  dateVariants_insert(data: {
    id: $id,
    nonNullValue: $nonNullValue,
    nullableWithNullValue: $nullableWithNullValue,
    nullableWithNonNullValue: $nullableWithNonNullValue,
    minValue: $minValue,
    maxValue: $maxValue,
    nonZeroTime: $nonZeroTime,
  })
}

query GetDateVariantsById($id: String!) @auth(level: PUBLIC) {
  dateVariants(id: $id) {
    nonNullValue
    nullableWithNullValue
    nullableWithNonNullValue
    minValue
    maxValue
    nonZeroTime
  }
}

mutation InsertSyntheticId($value: String!) @auth(level: PUBLIC) {
  syntheticId_insert(data: { value: $value })
}

query GetSyntheticIdById($id: UUID!) @auth(level: PUBLIC) {
  syntheticId(id: $id) { id value }
}

mutation InsertPrimaryKeyIsString($id: String!, $value: String!) @auth(level: PUBLIC) {
  primaryKeyIsString_insert(data: {
    id: $id,
    value: $value
  })
}

query GetPrimaryKeyIsStringByKey($key: PrimaryKeyIsString_Key!) @auth(level: PUBLIC) {
  primaryKeyIsString(key: $key) { id value }
}

mutation InsertPrimaryKeyIsUUID($id: UUID!, $value: String!) @auth(level: PUBLIC) {
  primaryKeyIsUUID_insert(data: {
    id: $id,
    value: $value
  })
}

query GetPrimaryKeyIsUUIDByKey($key: PrimaryKeyIsUUID_Key!) @auth(level: PUBLIC) {
  primaryKeyIsUUID(key: $key) { id value }
}

mutation InsertPrimaryKeyIsInt($foo: Int!, $value: String!) @auth(level: PUBLIC) {
  # NOTE: Use "upsert" instead of "insert" in this specific case since Int only has a 32-bit
  # representation, increasing the likelihood of conflicts. In the unlikely case of an ID being
  # used that already exists, it will just be replaced. There is a minuscule chance that the test
  # that generated the conflicting ID is running concurrently, but that chance is so small that I'm
  # choosing to ignore it.
  primaryKeyIsInt_upsert(data: {
    foo: $foo,
    value: $value
  })
}

query GetPrimaryKeyIsIntByKey($key: PrimaryKeyIsInt_Key!) @auth(level: PUBLIC) {
  primaryKeyIsInt(key: $key) { foo value }
}

mutation InsertPrimaryKeyIsFloat($foo: Float!, $value: String!) @auth(level: PUBLIC) {
  # NOTE: Use "upsert" instead of "insert" in this specific case since Float values are generated
  # using a pseudo-random number generator, which has a non-zero chance of conflicts. In the
  # unlikely case of an value being used that already exists, it will just be replaced. There is a
  # minuscule chance that the test that generated the conflicting ID is running concurrently, but
  # that chance is so small that I'm choosing to ignore it.
  primaryKeyIsFloat_upsert(data: {
    foo: $foo,
    value: $value
  })
}

query GetPrimaryKeyIsFloatByKey($key: PrimaryKeyIsFloat_Key!) @auth(level: PUBLIC) {
  primaryKeyIsFloat(key: $key) { foo value }
}

mutation InsertPrimaryKeyIsDate($foo: Date!, $value: String!) @auth(level: PUBLIC) {
  # NOTE: Use "upsert" instead of "insert" in this specific case since Date values are generated
  # using a pseudo-random number generator, which has a non-zero chance of conflicts. In the
  # unlikely case of an value being used that already exists, it will just be replaced. There is a
  # minuscule chance that the test that generated the conflicting ID is running concurrently, but
  # that chance is so small that I'm choosing to ignore it.
  primaryKeyIsDate_upsert(data: {
    foo: $foo,
    value: $value
  })
}

query GetPrimaryKeyIsDateByKey($key: PrimaryKeyIsDate_Key!) @auth(level: PUBLIC) {
  primaryKeyIsDate(key: $key) { foo value }
}

mutation InsertPrimaryKeyIsTimestamp($foo: Timestamp!, $value: String!) @auth(level: PUBLIC) {
  # NOTE: Use "upsert" instead of "insert" in this specific case since Timestamp values are
  # generated using a pseudo-random number generator, which has a non-zero chance of conflicts. In
  # the unlikely case of an value being used that already exists, it will just be replaced. There is
  # a minuscule chance that the test that generated the conflicting ID is running concurrently, but
  # that chance is so small that I'm choosing to ignore it.
  primaryKeyIsTimestamp_upsert(data: {
    foo: $foo,
    value: $value
  })
}

query GetPrimaryKeyIsTimestampByKey($key: PrimaryKeyIsTimestamp_Key!) @auth(level: PUBLIC) {
  primaryKeyIsTimestamp(key: $key) { foo value }
}

mutation InsertPrimaryKeyIsInt64($foo: Int64!, $value: String!) @auth(level: PUBLIC) {
  primaryKeyIsInt64_upsert(data: {
    foo: $foo,
    value: $value
  })
}

query GetPrimaryKeyIsInt64ByKey($key: PrimaryKeyIsInt64_Key!) @auth(level: PUBLIC) {
  primaryKeyIsInt64(key: $key) { foo value }
}

mutation InsertPrimaryKeyIsComposite($foo: Int!, $bar: String!, $baz: Boolean!, $value: String!) @auth(level: PUBLIC) {
  primaryKeyIsComposite_insert(data: {
    foo: $foo,
    bar: $bar,
    baz: $baz,
    value: $value
  })
}

query GetPrimaryKeyIsCompositeByKey($key: PrimaryKeyIsComposite_Key!) @auth(level: PUBLIC) {
  primaryKeyIsComposite(key: $key) { foo bar baz value }
}

mutation InsertPrimaryKeyNested1($value: String!) @auth(level: PUBLIC) {
  primaryKeyNested1_insert(data: { value: $value } )
}

mutation InsertPrimaryKeyNested2($value: String!) @auth(level: PUBLIC) {
  primaryKeyNested2_insert(data: { value: $value } )
}

mutation InsertPrimaryKeyNested3($value: String!) @auth(level: PUBLIC) {
  primaryKeyNested3_insert(data: { value: $value } )
}

mutation InsertPrimaryKeyNested4($value: String!) @auth(level: PUBLIC) {
  primaryKeyNested4_insert(data: { value: $value } )
}

mutation InsertPrimaryKeyNested5(
  $value: String!,
  $nested1: PrimaryKeyNested1_Key!,
  $nested2: PrimaryKeyNested2_Key!
) @auth(level: PUBLIC) {
  primaryKeyNested5_insert(data: {
    value: $value,
    nested1: $nested1,
    nested2: $nested2
  })
}

mutation InsertPrimaryKeyNested6(
  $value: String!,
  $nested3: PrimaryKeyNested3_Key!,
  $nested4: PrimaryKeyNested4_Key!
) @auth(level: PUBLIC) {
  primaryKeyNested6_insert(data: {
    value: $value,
    nested3: $nested3,
    nested4: $nested4
  })
}

mutation InsertPrimaryKeyNested7(
  $value: String!,
  $nested5a: PrimaryKeyNested5_Key!,
  $nested5b: PrimaryKeyNested5_Key!,
  $nested6: PrimaryKeyNested6_Key!
) @auth(level: PUBLIC) {
  primaryKeyNested7_insert(data: {
    value: $value,
    nested5a: $nested5a,
    nested5b: $nested5b,
    nested6: $nested6
  })
}

query GetPrimaryKeyNested7ByKey($key: PrimaryKeyNested7_Key!) @auth(level: PUBLIC) {
  primaryKeyNested7(key: $key) {
    value
    nested5a {
      value
      nested1 {
        id
        value
      }
      nested2 {
        id
        value
      }
    }
    nested5b {
      value
      nested1 {
        id
        value
      }
      nested2 {
        id
        value
      }
    }
    nested6 {
      value
      nested3 {
        id
        value
      }
      nested4 {
        id
        value
      }
    }
  }
}

mutation InsertNested1(
    $nested1: Nested1_Key,
    $nested2: Nested2_Key!,
    $nested2NullableNonNull: Nested2_Key,
    $nested2NullableNull: Nested2_Key,
    $value: String!
) @auth(level: PUBLIC) {
  nested1_insert(data: {
    nested1: $nested1,
    nested2: $nested2,
    nested2NullableNonNull: $nested2NullableNonNull,
    nested2NullableNull: $nested2NullableNull,
    value: $value
  })
}

query GetNested1ByKey($key: Nested1_Key!) @auth(level: PUBLIC) {
  nested1(key: $key) {
    id
    nested1 {
      id
      nested1 { id }
      nested2 {
        id
        value
        nested3 {
          id
          value
        }
        nested3NullableNull {
          id
          value
        }
        nested3NullableNonNull {
          id
          value
        }
      }
      nested2NullableNull {
        id
        value
        nested3 {
          id
          value
        }
        nested3NullableNull {
          id
          value
        }
        nested3NullableNonNull {
          id
          value
        }
      }
      nested2NullableNonNull {
        id
        value
        nested3 {
          id
          value
        }
        nested3NullableNull {
          id
          value
        }
        nested3NullableNonNull {
          id
          value
        }
      }
    }
    nested2 {
      id
      value
      nested3 {
        id
        value
      }
      nested3NullableNull {
        id
        value
      }
      nested3NullableNonNull {
        id
        value
      }
    }
    nested2NullableNonNull {
      id
      value
      nested3 {
        id
        value
      }
      nested3NullableNull {
        id
        value
      }
      nested3NullableNonNull {
        id
        value
      }
    }
    nested2NullableNull {
      id
      value
      nested3 {
        id
        value
      }
      nested3NullableNull {
        id
        value
      }
      nested3NullableNonNull {
        id
        value
      }
    }
  }
}

mutation InsertNested2(
    $nested3: Nested3_Key!,
    $nested3NullableNonNull: Nested3_Key,
    $nested3NullableNull: Nested3_Key,
    $value: String!
) @auth(level: PUBLIC) {
  nested2_insert(data: {
    nested3: $nested3,
    nested3NullableNonNull: $nested3NullableNonNull,
    nested3NullableNull: $nested3NullableNull,
    value: $value
  })
}

mutation InsertNested3($value: String!) @auth(level: PUBLIC) {
  nested3_insert(data: { value: $value })
}

mutation InsertManyToOneParent($child: ManyToOneChild_Key) @auth(level: PUBLIC) {
  manyToOneParent_insert(data: { child: $child })
}

mutation InsertManyToOneChild @auth(level: PUBLIC) {
  manyToOneChild_insert(data: {value: null})
}

query GetManyToOneChildByKey($key: ManyToOneChild_Key!) @auth(level: PUBLIC) {
  manyToOneChild(key: $key) {
    parents: manyToOneParents_on_child {
      id
    }
  }
}

mutation InsertManyToManyChildA @auth(level: PUBLIC) {
  manyToManyChildA_insert(data: {})
}

mutation InsertManyToManyChildB @auth(level: PUBLIC) {
  manyToManyChildB_insert(data: {})
}

mutation InsertManyToManyParent($childA: ManyToManyChildA_Key!, $childB: ManyToManyChildB_Key!) @auth(level: PUBLIC) {
  manyToManyParent_insert(data: {childA: $childA, childB: $childB})
}

query GetManyToManyChildAByKey($key: ManyToManyChildA_Key!) @auth(level: PUBLIC) {
  manyToManyChildA(key: $key) {
    manyToManyChildBS_via_ManyToManyParent {
      id
    }
  }
}

mutation InsertManyToOneSelfCustomName($ref: ManyToOneSelfCustomName_Key) @auth(level: PUBLIC) {
  manyToOneSelfCustomName_insert(data: {ref: $ref})
}

query GetManyToOneSelfCustomNameByKey($key: ManyToOneSelfCustomName_Key!) @auth(level: PUBLIC) {
  manyToOneSelfCustomName(key: $key) {
    id
    ref {
      id
      refId
    }
  }
}

mutation InsertManyToOneSelfMatchingName($ref: ManyToOneSelfMatchingName_Key) @auth(level: PUBLIC) {
  manyToOneSelfMatchingName_insert(data: {manyToOneSelfMatchingName: $ref})
}

query GetManyToOneSelfMatchingNameByKey($key: ManyToOneSelfMatchingName_Key!) @auth(level: PUBLIC) {
  manyToOneSelfMatchingName(key: $key) {
    id
    manyToOneSelfMatchingName {
      id
      manyToOneSelfMatchingNameId
    }
  }
}

mutation InsertManyToManySelfParent($child1: ManyToManySelfChild_Key!, $child2: ManyToManySelfChild_Key!) @auth(level: PUBLIC) {
  manyToManySelfParent_insert(data: {child1: $child1, child2: $child2})
}

mutation InsertManyToManySelfChild @auth(level: PUBLIC) {
  manyToManySelfChild_insert(data: {})
}

query GetManyToManySelfChildByKey($key: ManyToManySelfChild_Key!) @auth(level: PUBLIC) {
  manyToManySelfChild(key: $key) {
    manyToManySelfChildren_via_ManyToManySelfParent_on_child1 { id }
    manyToManySelfChildren_via_ManyToManySelfParent_on_child2 { id }
  }
}

mutation InsertOptionalStrings(
  $required1: String!,
  $required2: String!,
  $nullable1: String,
  $nullable2: String,
  $nullable3: String,
  $nullableWithSchemaDefault: String,
) @auth(level: PUBLIC) {
  optionalStrings_insert(data: {
    required1: $required1,
    required2: $required2,
    nullable1: $nullable1,
    nullable2: $nullable2,
    nullable3: $nullable3,
    nullableWithSchemaDefault: $nullableWithSchemaDefault,
  })
}

query GetOptionalStringsByKey($key: OptionalStrings_Key!) @auth(level: PUBLIC) {
  optionalStrings(key: $key) {
    required1
    required2
    nullable1
    nullable2
    nullable3
    nullableWithSchemaDefault
  }
}
